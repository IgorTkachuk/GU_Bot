Это Telegram бот (MVP).

Бот находится в процессе написания, изобилует множеством архитектурных костылей или
отсутсвием архитектуры, зачастую реализован happy path без корректных обработок
ошибок или централизованной обработки ошибок.

Для запуска нужно создать бота через BotFather и получить для него токен.

Также нужен GitHub Personal Access Token (PAT).
Для этого создаю служебный аккаунт GitHub. Далее `Settings -> Developer settings -> Personal access tokens`.
Прописываю его либо в конфиг файл либо через переменную окружения  `GITHUB_TOKEN`

Для работы также потребуется запущенный Redis:

`docker run --rm --name some-redis -p 6379:6379 -d redis`

а также либо правильно заполненный конфиг `config.yaml` либо переменные окружения.
Я использую на данный момент переменные окружения `BOT_TOKEN=` и `GITHUB_TOKEN` с дефолтным конфигом.

Бот на данный момент умеет:
**В комманды:**

1. /hello
2. /register
3. /repoinfo

По комманде `/hello` просто вернет "Hello, <имя пользователя>"

По комманде `/register` начнет процесс регистрации пользователя. 
Т.к. на данный момент отсутствует доступ к API WEB сервиса, то для имитации процесса будет
сгенерирован уникальный UUID и выведен в консоль. 

Для имитации успешной регистрации можно скопировать этот UUID и отправить боту в ответ на
запрос токена.

В случае успешной регистрации данная информация будет сохранена в базе key-value.
При повторной попытке запуска процесса регистрации для уже успешно зарегестрированного
пользователя - пользователю будет выведено сообщение, что он уже зарегестирован.

В случае неверно введеного токена - бот генерирует клавиатуру с кнопками повтора процесса либо 
его отмены.

По комманде `/repoinfo` бот должен сходить на Web сервис, взять оттуда репозиторий (репозитории)
пользователя и выполнить запрос на API GitHub отобразив пользователю содержимое файла
README.md из корня репозитория ветки main(master). На данный момент функция получения
репозитория пользователя замокана и возвращает только строку. Т.о. бот всегда ходит
за инфой в один и тот-же репозиторий.

Также реализован **REST API** содержащий на данный момент два ендпоинта http://localhost:8080:
Порт захардкожен - ничего не мешает его вынести в когфиг.

1. /api/news
2. /api/events/<group name>

`/api/news` - принимает POST запрос, читает тело запроса и рассылает его содержимое всем
пользователям

###### Пример запроса: ` curl -d "Some news" -X POST http://localhost:8080/api/news`

`/api/events/<group name>` - принимает POST запрос, интерпритирует тело запроса как JSON 
формата `{ "message": "event message"}` и рассылет содержимое поля `message` всем
участникам группы `<group name>`. Тут стоить заметить, что пока не ясно как эти группы
пользователей будут формироваться и синхронизироваться с WEB сервисом. Изначально 
информация о каждом пользователе бота, который начал с ним диалог сохраняется в
базе key-value с группой `all`. 

###### Пример запроса: (здесь группа all за неимением другой)` curl -d "{ \"message\": \"event message\"}" -X POST http://localhost:8080/api/events/all`


